{"version":3,"file":"utils.js","sources":["../../../../src/internal/positioning/utils.ts"],"sourcesContent":["/*\n * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\nimport { Positions, } from './interfaces.js';\nimport { capitalizeFirstLetter, removePrefix, transformSpacedStringToArray } from '../utils/string.js';\nimport { getWindowDimensions, setAttributes } from '../utils/dom.js';\nimport { isNil } from '../utils/identity.js';\nimport { getCssPropertyValue, updateElementStyles } from '../utils/css.js';\nimport { sumAndSubtract } from '../utils/math.js';\nimport { getEnumValueFromStringKey } from '../utils/enum.js';\nexport function getPopupOffsetOrDefaultOffsets(existingMainAxisOffset, existingCrossAxisOffset, pointer, pointerAlign, anchorAlign) {\n    const returnObj = { mainAxisOffset: 0, crossAxisOffset: 0 };\n    const isDefaultPointerType = pointer && pointer.type === 'default';\n    if (!isNil(existingMainAxisOffset)) {\n        returnObj.mainAxisOffset = existingMainAxisOffset;\n    }\n    else {\n        if (isDefaultPointerType) {\n            returnObj.mainAxisOffset = -10;\n        }\n    }\n    if (!isNil(existingCrossAxisOffset)) {\n        returnObj.crossAxisOffset = existingCrossAxisOffset;\n    }\n    else {\n        if (isDefaultPointerType && pointerAlign === 'end' && anchorAlign === 'start') {\n            returnObj.crossAxisOffset = -10;\n        }\n    }\n    return returnObj;\n}\nexport function setPopupPosition(component) {\n    // have to pre-emptively remove stealth attr so that measurements won't take responsive width/height\n    // as the popup's actual width/height\n    component.removeAttribute('responsive');\n    const offsets = getPopupOffsetOrDefaultOffsets(component.mainAxisOffset, component.crossAxisOffset, component.pointer, component.pointerAlign, component.anchorAlign);\n    const myPosition = getPopupPosition(component.orientation, component.anchorRect, component.anchorAlign, component.pointer, component.pointerAlign, component.contentWrapper, offsets.mainAxisOffset, offsets.crossAxisOffset);\n    if (myPosition === false) {\n        // have to manually set this here because the CSS needs it and the work needs to\n        // happen outside of the update loop\n        setAttributes(component, ['responsive', ''], ['_position-at', false]);\n        updateElementStyles(component.hostWrapper, ['position', ''], ['top', ''], ['left', '']);\n        updateElementStyles(component.pointerWrapper, ['visibility', 'hidden']);\n    }\n    else {\n        if (component.pointer) {\n            const positionedPointer = myPosition.pointer;\n            updateElementStyles(component.pointerWrapper, ['visibility', 'visible']);\n            setAttributes(component, ['_pointer-type', component.pointer.type || false]);\n            setAttributes(component, ['_position-at', positionedPointer.location]);\n        }\n        else {\n            updateElementStyles(component.pointerWrapper, ['visibility', 'hidden']);\n            setAttributes(component, ['_position-at', false], ['_pointer-type', false]);\n        }\n        const posTop = myPosition.popup.top + 'px';\n        const posLeft = myPosition.popup.left + 'px';\n        updateElementStyles(component.hostWrapper, ['position', 'absolute'], ['top', posTop], ['left', posLeft]);\n    }\n}\nexport function getOrientationTuple(orientationPrefs) {\n    const preferredPositions = [];\n    const deniedPositions = [];\n    /* c8 ignore next */\n    for (const userPref of transformSpacedStringToArray(orientationPrefs)) {\n        if (userPref === 'none') {\n            return [[], 0];\n        }\n        else if (userPref.indexOf('only:') > -1) {\n            return [\n                [getEnumValueFromStringKey(Positions, removePrefix(userPref, 'only:'), capitalizeFirstLetter)],\n                0,\n            ];\n        }\n        else if (userPref.indexOf('not:') > -1) {\n            deniedPositions.push(getEnumValueFromStringKey(Positions, removePrefix(userPref, 'not:'), capitalizeFirstLetter));\n        }\n        else {\n            const positionVal = getEnumValueFromStringKey(Positions, userPref, capitalizeFirstLetter);\n            deniedPositions.push(positionVal);\n            preferredPositions.push(positionVal);\n        }\n    }\n    return [preferredPositions, sumAndSubtract(0, [Positions.All], deniedPositions)];\n}\nexport function getCrossAxisOrderOfPreference(preference) {\n    switch (preference) {\n        case 'mid':\n            return [1, 0, 2];\n        case 'end':\n            return [2, 1, 0];\n        case 'start':\n        default:\n            return [0, 1, 2];\n    }\n}\nexport function checkNextPosition(whichPosition, positions, anchorAlignPref) {\n    if (positions === false) {\n        return false;\n    }\n    const positionToCheck = positions[Positions[whichPosition]?.toLowerCase()];\n    if (!positionToCheck) {\n        return false;\n    }\n    const [startOfAnchor, middleOfAnchor, endOfAnchor] = positionToCheck;\n    if (startOfAnchor === false && middleOfAnchor === false && endOfAnchor === false) {\n        return false;\n    }\n    for (const i of getCrossAxisOrderOfPreference(anchorAlignPref)) {\n        if (positionToCheck[i]) {\n            return Object.assign({}, positionToCheck[i]);\n        }\n    }\n    return false;\n}\nexport function getNextDefaultPosition(currentPositionTotal) {\n    const defaults = [Positions.Bottom, Positions.Right, Positions.Left, Positions.Top, Positions.Responsive];\n    for (const position of defaults) {\n        if (currentPositionTotal >= position) {\n            return [position, currentPositionTotal - position];\n        }\n    }\n    return [0, 0];\n}\nexport function getNextPosition(userPrefs, prefTotal) {\n    if (userPrefs.length < 1) {\n        const [positionIndexToCheck, newPrefTotal] = getNextDefaultPosition(prefTotal);\n        return [positionIndexToCheck, userPrefs, newPrefTotal];\n    }\n    return [userPrefs[0], userPrefs.slice(1), userPrefs[0] !== Positions.Responsive ? prefTotal : 0];\n}\n/* c8 ignore next */\nexport function getPointerPosition(workingPositionRelativeToAnchor) {\n    switch (workingPositionRelativeToAnchor.toLowerCase()) {\n        case 'top':\n            return 'popup-bottom';\n        case 'bottom':\n            return 'popup-top';\n        case 'left':\n            return 'popup-right';\n        case 'right':\n        default:\n            return 'popup-left';\n    }\n}\nexport function getPointerAlignment(popupPosition, pointerAlign) {\n    let myAligns;\n    if (popupPosition === 'popup-bottom' || popupPosition === 'popup-top') {\n        myAligns = { start: 'pointer-left', mid: 'pointer-center', end: 'pointer-right' };\n    }\n    else {\n        myAligns = { start: 'pointer-top', mid: 'pointer-mid', end: 'pointer-bottom' };\n    }\n    return myAligns[pointerAlign];\n}\nexport function getBestPositionForPreferences(positions, preferences, anchorAlignPref) {\n    let [arrayOfUserPrefs, currentPrefTotal] = preferences;\n    let returnPref = null;\n    while (returnPref === null) {\n        const [positionToCheck, newArrayOfUserPrefs, newCurrentPrefTotal] = getNextPosition(arrayOfUserPrefs, currentPrefTotal);\n        const positionWillWork = checkNextPosition(positionToCheck, positions, anchorAlignPref);\n        switch (true) {\n            case positionWillWork !== false:\n                returnPref = Object.assign({}, positionWillWork, {\n                    pointer: { location: getPointerPosition(Positions[positionToCheck]) },\n                });\n                break;\n            case positionWillWork === false && newCurrentPrefTotal === 0:\n                // tested all positions; none of them work\n                returnPref = false;\n                break;\n            case positionWillWork === false:\n                // this position won't work but there are more positions to check!\n                arrayOfUserPrefs = newArrayOfUserPrefs;\n                currentPrefTotal = newCurrentPrefTotal;\n                break;\n        }\n    }\n    return returnPref;\n}\nexport function getPopupPosition(orientationPrefs, anchorRect, anchorAlign, pointer, pointerAlign, popup, mainAxisOffset, crossAxisOffset) {\n    if (!anchorRect) {\n        return false; // anchor does not exist; force responsive\n    }\n    // we have to use offsetHeight/Width here because the DOMRect shifts dimensions when the pointer is rotated\n    // the caveat with using offsetHeight/Width is that the values are rounded to an integer\n    // that does not seem to be a big risk, however, because these pointers are created by users.\n    // if there is a rounding issue, it's likely because a rem sizing has something set to a fractional value\n    // and any rounding error would likely be negligible in effect\n    const pointerHeight = pointer ? pointer.offsetHeight : 0;\n    const windowDims = getWindowDimensions();\n    /* c8 ignore next 3 */\n    if (windowDims.width <= parseInt(getCssPropertyValue('--cds-global-layout-width-xs-static'), 10)) {\n        return false;\n    }\n    const positions = getPositions(anchorRect, pointerHeight, pointerAlign, popup.getBoundingClientRect(), windowDims, mainAxisOffset, crossAxisOffset);\n    const myPosition = getBestPositionForPreferences(positions, getOrientationTuple(orientationPrefs), anchorAlign);\n    if (myPosition === false) {\n        return false;\n    }\n    const pointerLocationRelativeToAnchor = myPosition.pointer.location;\n    const pointerLocation = pointerLocationRelativeToAnchor + ' ' + getPointerAlignment(pointerLocationRelativeToAnchor, pointerAlign);\n    const pointerObj = { pointer: { size: pointerHeight, location: pointerLocation } };\n    return Object.assign({}, myPosition, pointerObj);\n}\nexport function getPositions(anchorRect, pointerHeight, pointerAlign, popupRect, windowDims, mainAxisOffset, crossAxisOffset) {\n    return {\n        top: getPositionConfig('top', pointerAlign, anchorRect, popupRect, pointerHeight, windowDims, mainAxisOffset, crossAxisOffset),\n        right: getPositionConfig('right', pointerAlign, anchorRect, popupRect, pointerHeight, windowDims, mainAxisOffset, crossAxisOffset),\n        bottom: getPositionConfig('bottom', pointerAlign, anchorRect, popupRect, pointerHeight, windowDims, mainAxisOffset, crossAxisOffset),\n        left: getPositionConfig('left', pointerAlign, anchorRect, popupRect, pointerHeight, windowDims, mainAxisOffset, crossAxisOffset),\n    };\n}\n// TODO: convert arguments list to a config object?\nexport function getPositionConfig(cardinalPos, pointerAlign, anchor, popup, pointerHeight, win, mainAxisOffset, crossAxisOffset) {\n    let mainAxisPosition;\n    switch (cardinalPos) {\n        case 'top':\n            mainAxisPosition = getMainAxisPositionOrViolation(anchor.top, pointerHeight, popup.height, mainAxisOffset, 0);\n            if (mainAxisPosition === false) {\n                return false;\n            }\n            else {\n                return getPositionOrViolationFromCrossAxis(anchor.left, anchor.width, popup.width, crossAxisOffset, 0, win.width, pointerAlign).map((crossAxisPos) => {\n                    if (crossAxisPos === false) {\n                        return false;\n                    }\n                    else {\n                        return {\n                            popup: {\n                                top: mainAxisPosition,\n                                left: crossAxisPos,\n                            },\n                        };\n                    }\n                });\n            }\n        case 'bottom':\n            mainAxisPosition = getMainAxisPositionOrViolation(anchor.bottom, 0, // pointer doesn't need to be in this calc\n            popup.height, mainAxisOffset, win.height);\n            if (mainAxisPosition === false) {\n                return false;\n            }\n            else {\n                return getPositionOrViolationFromCrossAxis(anchor.left, anchor.width, popup.width, crossAxisOffset, 0, win.width, pointerAlign).map((crossAxisPos) => {\n                    if (crossAxisPos === false) {\n                        return false;\n                    }\n                    else {\n                        return {\n                            popup: {\n                                top: mainAxisPosition,\n                                left: crossAxisPos,\n                            },\n                        };\n                    }\n                });\n            }\n        case 'left':\n            mainAxisPosition = getMainAxisPositionOrViolation(anchor.left, pointerHeight, popup.width, mainAxisOffset, 0);\n            if (mainAxisPosition === false) {\n                return false;\n            }\n            else {\n                return getPositionOrViolationFromCrossAxis(anchor.top, anchor.height, popup.height, crossAxisOffset, 0, win.height, pointerAlign).map((crossAxisPos) => {\n                    if (crossAxisPos === false) {\n                        return false;\n                    }\n                    else {\n                        return {\n                            popup: {\n                                top: crossAxisPos,\n                                left: mainAxisPosition,\n                            },\n                        };\n                    }\n                });\n            }\n        case 'right':\n            mainAxisPosition = getMainAxisPositionOrViolation(anchor.right, 0, // pointer doesn't need to be in this calc\n            popup.width, mainAxisOffset, win.width);\n            if (mainAxisPosition === false) {\n                return false;\n            }\n            else {\n                return getPositionOrViolationFromCrossAxis(anchor.top, anchor.height, popup.height, crossAxisOffset, 0, win.height, pointerAlign).map((crossAxisPos) => {\n                    if (crossAxisPos === false) {\n                        return false;\n                    }\n                    else {\n                        return {\n                            popup: {\n                                top: crossAxisPos,\n                                left: mainAxisPosition,\n                            },\n                        };\n                    }\n                });\n            }\n    }\n}\nexport function getMainAxisPosition(startPos, pointer, popup, offset, limit) {\n    return limit === 0\n        ? sumAndSubtract(startPos, [], [pointer, popup, offset])\n        : sumAndSubtract(startPos, [pointer, popup, offset], []);\n}\nexport function testMainAxisPosition(pos, startPos, limit) {\n    if (limit === 0) {\n        // -- for positions that *pull* (a.k.a top and left) --\n        // if limit is zero, see if position is above zero and return it\n        return pos > limit && pos;\n    }\n    else {\n        // -- for positions that *push* (a.k.a. bottom and right)\n        // if limit is not zero, position is the start + popup dimension;\n        // return start position if position is less than the limit\n        return pos < limit && startPos; // needs offsets!\n    }\n}\nexport function getCrossAxisPosition(position, startPos, anchorAlign, anchorWidth, offset, popup = 0) {\n    switch (position) {\n        case 'mid':\n            return startPos + anchorAlign * anchorWidth - 0.5 * popup + offset;\n        case 'end':\n            return startPos + anchorAlign * anchorWidth - offset;\n        case 'start':\n            return startPos + anchorAlign * anchorWidth + offset;\n    }\n}\nexport function testCrossAxisPosition(axisAlign, position, popup, limit) {\n    const [limitMin, limitMax] = limit;\n    switch (axisAlign) {\n        case 'mid':\n            return position > limitMin && position + popup < limitMax ? position : false;\n        case 'end': {\n            const pulledPosition = position - popup;\n            return pulledPosition > limitMin ? pulledPosition : false;\n        }\n        case 'start':\n            return position + popup < limitMax ? position : false;\n    }\n}\nexport function getPositionOrViolationFromCrossAxis(startPos, anchorLength, popupLength, offset, limitMinimum, limitMaximum, pointerPosition) {\n    const anchorAlignments = [0, 0.5, 1];\n    return anchorAlignments.map((anchorAlignment) => {\n        return testCrossAxisPosition(pointerPosition, getCrossAxisPosition(pointerPosition, startPos, anchorAlignment, anchorLength, offset, popupLength), popupLength, [limitMinimum, limitMaximum]);\n    });\n}\nexport function getMainAxisPositionOrViolation(startPos, pointerLength, popupLength, offset, limit = 0) {\n    return testMainAxisPosition(getMainAxisPosition(startPos, pointerLength, popupLength, offset, limit), // returned by *pull* positions\n    startPos + offset, // only returned with *push* positions\n    limit);\n}\n"],"names":["getPopupOffsetOrDefaultOffsets","existingMainAxisOffset","existingCrossAxisOffset","pointer","pointerAlign","anchorAlign","returnObj","mainAxisOffset","crossAxisOffset","isDefaultPointerType","type","isNil","setPopupPosition","component","removeAttribute","offsets","myPosition","getPopupPosition","orientation","anchorRect","contentWrapper","setAttributes","updateElementStyles","hostWrapper","pointerWrapper","positionedPointer","location","posTop","popup","top","posLeft","left","getOrientationTuple","orientationPrefs","preferredPositions","deniedPositions","userPref","transformSpacedStringToArray","indexOf","getEnumValueFromStringKey","Positions","removePrefix","capitalizeFirstLetter","push","positionVal","sumAndSubtract","All","getCrossAxisOrderOfPreference","preference","checkNextPosition","whichPosition","positions","anchorAlignPref","positionToCheck","toLowerCase","startOfAnchor","middleOfAnchor","endOfAnchor","i","Object","assign","getNextDefaultPosition","currentPositionTotal","defaults","Bottom","Right","Left","Top","Responsive","position","getNextPosition","userPrefs","prefTotal","length","positionIndexToCheck","newPrefTotal","slice","getPointerPosition","workingPositionRelativeToAnchor","getPointerAlignment","popupPosition","myAligns","start","mid","end","getBestPositionForPreferences","preferences","arrayOfUserPrefs","currentPrefTotal","returnPref","newArrayOfUserPrefs","newCurrentPrefTotal","positionWillWork","pointerHeight","offsetHeight","windowDims","getWindowDimensions","width","parseInt","getCssPropertyValue","getPositions","getBoundingClientRect","pointerLocationRelativeToAnchor","pointerLocation","size","popupRect","getPositionConfig","right","bottom","cardinalPos","anchor","win","mainAxisPosition","getMainAxisPositionOrViolation","height","getPositionOrViolationFromCrossAxis","map","crossAxisPos","getMainAxisPosition","startPos","offset","limit","testMainAxisPosition","pos","getCrossAxisPosition","anchorWidth","testCrossAxisPosition","axisAlign","limitMin","limitMax","pulledPosition","anchorLength","popupLength","limitMinimum","limitMaximum","pointerPosition","anchorAlignment","pointerLength"],"mappings":"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"}