{"version":3,"file":"dom.js","sources":["../../../../src/internal/utils/dom.ts"],"sourcesContent":["/*\n * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\nimport includes from 'ramda/es/includes';\nimport without from 'ramda/es/without';\nimport { getCssPropertyValue } from './css.js';\nimport { pluckPixelValue, transformSpacedStringToArray } from './string.js';\nimport { isNumericString, isStringAndNotNilOrEmpty } from './identity.js';\n/**\n * We are not going to be opinionated about the use of the disabled attribute here.\n * Browsers will manage that on their own. The focus of this is to determine whether\n * or not a tabindex should be set on an element to make it programmatically\n * focusable.\n *\n */\nexport function isFocusable(element) {\n    /* c8 ignore next 21 */\n    switch (element.tagName.toLowerCase()) {\n        case 'input':\n            return (element.getAttribute('type') !== 'hidden' &&\n                !element.hasAttribute('disabled') &&\n                !element.hasAttribute('readonly'));\n        case 'button':\n        case 'select':\n        case 'textarea':\n            return !element.hasAttribute('disabled');\n        case 'iframe':\n        case 'embed':\n        case 'object':\n            return true;\n        case 'a':\n        case 'area':\n            return element.hasAttribute('href');\n        case 'audio':\n        case 'video':\n            return element.hasAttribute('controls');\n        default:\n            // we are not going to get into invalid values sent to the\n            // tabindex attr. users have control of that and should avoid\n            // setting tabindex to weird/unsupported values.\n            return (element.hasAttribute('tabindex') ||\n                element.getAttribute('contenteditable') === 'true' ||\n                (element.getAttribute('role') === 'button' && !element.hasAttribute('disabled')));\n    }\n}\n/* c8 ignore next */\nexport function isScrollable(element) {\n    // early return here in the event element looked up but not in the dom at present\n    if (!element) {\n        return false;\n    }\n    // there's no great way to determine if something has scrollbars or not\n    // this calculation is... okay at it. it is slightly naive but covers\n    // our current need/use-case. if we need something more robust, we can\n    // update this function to use one of the more complicated checks.\n    const boundingRect = element.getBoundingClientRect();\n    return (boundingRect.top < 0 ||\n        element.scrollHeight > element.offsetHeight ||\n        boundingRect.left < 0 ||\n        element.scrollWidth > element.clientWidth);\n}\n/**\n * Works only on light DOM because that is all we have needed it for thus far\n *\n */\n/* c8 ignore next */\nexport function queryAllFocusable(element) {\n    return element.querySelectorAll(tabFlowSelectors.join(', '));\n}\nconst nonTabIndexFocusableSelectors = [\n    'a[href]',\n    'area[href]',\n    'audio[controls]',\n    'button:not([disabled])',\n    'input:not([type=\"hidden\"]):not([disabled]):not([readonly])',\n    'iframe',\n    'object',\n    'embed',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'video[controls]',\n    '*[contenteditable=true]',\n    '[role=button]:not([disabled])',\n];\nexport const focusableSelectors = ['*[tabindex]', ...nonTabIndexFocusableSelectors];\nexport const tabFlowSelectors = ['*[tabindex]:not([tabindex=\"-1\"])', ...nonTabIndexFocusableSelectors];\nexport function getElementWidth(element, unit = 'px') {\n    if (element) {\n        return element.getBoundingClientRect ? element.getBoundingClientRect().width + unit : '';\n    }\n    return '';\n}\nexport function getElementWidthUnless(element, unless) {\n    if (!unless) {\n        return getElementWidth(element);\n    }\n    return '';\n}\nexport function isHTMLElement(el) {\n    return !!el && el instanceof HTMLElement;\n}\nexport function hasAttributeAndIsNotEmpty(element, attribute) {\n    return !!element && element.hasAttribute(attribute) && isStringAndNotNilOrEmpty(element.getAttribute(attribute));\n}\nexport function setOrRemoveAttribute(element, attrTuple, test) {\n    const [attribute, value] = attrTuple;\n    if (test()) {\n        setAttributes(element, [attribute, value]);\n    }\n    else {\n        removeAttributes(element, attribute);\n    }\n}\nexport function setAttributes(element, ...attributeTuples) {\n    if (element) {\n        attributeTuples.forEach(([attr, val]) => {\n            if (val === false || val === null) {\n                element.removeAttribute(attr);\n            }\n            else {\n                element.setAttribute(attr, val + '');\n            }\n        });\n    }\n}\nexport function removeAttributes(element, ...attrs) {\n    if (element) {\n        attrs.forEach(attr => {\n            element.removeAttribute(attr);\n        });\n    }\n}\nexport function addAttributeValue(element, attr, value) {\n    if (element) {\n        const currentAttrVal = element.getAttribute(attr);\n        if (!currentAttrVal) {\n            element.setAttribute(attr, value);\n        }\n        else if (!includes(value, currentAttrVal.split(' '))) {\n            // add it only if it is not already there\n            element.setAttribute(attr, currentAttrVal + ' ' + value);\n        }\n    }\n}\nexport function removeAttributeValue(element, attr, value) {\n    if (element) {\n        const currentAttrVal = element.getAttribute(attr);\n        if (currentAttrVal) {\n            // remove the specified value from the list of values currently set\n            const attrValues = without([value], transformSpacedStringToArray(currentAttrVal));\n            const newAttrValue = attrValues.join(' ');\n            if (newAttrValue) {\n                element.setAttribute(attr, newAttrValue);\n            }\n            else {\n                element.removeAttribute(attr);\n            }\n        }\n    }\n}\nexport function assignSlotNames(...slotTuples) {\n    slotTuples.forEach(slotTuple => {\n        const [el, slotName] = slotTuple;\n        if (el) {\n            setAttributes(el, ['slot', slotName]);\n        }\n    });\n}\nexport function isVisible(element) {\n    return !!element && element?.offsetHeight > 0 && element?.hasAttribute('hidden') === false;\n}\nexport function spanWrapper(nodeList) {\n    Array.from(nodeList)\n        .filter(node => node.textContent && node.textContent.trim().length > 0 && node.nodeType === 3 && node.parentElement)\n        .forEach(node => {\n        const spanWrapper = document.createElement('span');\n        node.after(spanWrapper);\n        spanWrapper.appendChild(node);\n    });\n}\nexport function queryChildFromLightOrShadowDom(hostEl, selector) {\n    if (!selector) {\n        return null;\n    }\n    return hostEl.querySelector(selector) || hostEl?.shadowRoot?.querySelector(selector) || null;\n}\nexport function createFragment(tagString) {\n    return document.createRange().createContextualFragment(tagString);\n}\nexport function getWindowDimensions(win = window) {\n    const doc = win?.document;\n    const h = win?.innerHeight || doc?.documentElement?.clientHeight || 0;\n    const w = win?.innerWidth || doc?.documentElement?.clientWidth || 0;\n    return { width: w, height: h };\n}\nexport function windowIsAboveMobileBreakpoint(breakpointAsPixelValue) {\n    const breakpointVal = breakpointAsPixelValue || getCssPropertyValue('--cds-global-layout-width-xs').trim();\n    return breakpointAsPixelValue?.endsWith('px') ? pluckPixelValue(breakpointVal) >= getWindowDimensions().width : false;\n}\nexport function getShadowRootOrElse(hostEl, fallbackEl) {\n    const fallTo = fallbackEl ? fallbackEl : hostEl;\n    return (hostEl.shadowRoot ? hostEl.shadowRoot : fallTo);\n}\nexport function getInputValueType(value) {\n    if (isNumericString(value)) {\n        return 'number';\n    }\n    else if (value.match(/^\\d{4}-\\d{1,2}-\\d{1,2}$/)) {\n        return 'date';\n    }\n    else {\n        return 'text';\n    }\n}\n// todo cory: test\nexport function querySelectorRoots(element, selector) {\n    const root = element.querySelectorAll(selector);\n    const shadowRoot = element.shadowRoot?.querySelectorAll(selector);\n    return [...Array.from(root), ...Array.from(shadowRoot)];\n}\n// todo cory: test\n/**\n * Checks for right click with context menus & keyboard mouse control https://apple.stackexchange.com/questions/32715/how-do-i-open-the-context-menu-from-a-mac-keyboard\n */\nexport function contextMenuClick(event) {\n    return (event.buttons === 2 && !event.ctrlKey) || (event.buttons === 1 && event.ctrlKey);\n}\n/** Coerces attribute/property value to a boolean */\nexport function coerceBooleanProperty(value) {\n    return value !== null && value !== undefined && `${value}` !== 'false';\n}\n"],"names":["isFocusable","element","tagName","toLowerCase","getAttribute","hasAttribute","isScrollable","boundingRect","getBoundingClientRect","top","scrollHeight","offsetHeight","left","scrollWidth","clientWidth","queryAllFocusable","querySelectorAll","tabFlowSelectors","join","nonTabIndexFocusableSelectors","focusableSelectors","getElementWidth","unit","width","getElementWidthUnless","unless","isHTMLElement","el","HTMLElement","hasAttributeAndIsNotEmpty","attribute","isStringAndNotNilOrEmpty","setOrRemoveAttribute","attrTuple","test","value","setAttributes","removeAttributes","attributeTuples","forEach","attr","val","removeAttribute","setAttribute","attrs","addAttributeValue","currentAttrVal","includes","split","removeAttributeValue","newAttrValue","without","transformSpacedStringToArray","assignSlotNames","slotTuples","slotTuple","slotName","isVisible","spanWrapper","nodeList","Array","from","filter","node","textContent","trim","length","nodeType","parentElement","document","createElement","after","appendChild","queryChildFromLightOrShadowDom","hostEl","selector","querySelector","shadowRoot","createFragment","tagString","createRange","createContextualFragment","getWindowDimensions","win","window","doc","h","innerHeight","documentElement","clientHeight","innerWidth","height","windowIsAboveMobileBreakpoint","breakpointAsPixelValue","breakpointVal","getCssPropertyValue","endsWith","pluckPixelValue","getShadowRootOrElse","fallbackEl","fallTo","getInputValueType","isNumericString","match","querySelectorRoots","root","contextMenuClick","event","buttons","ctrlKey","coerceBooleanProperty"],"mappings":"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"}