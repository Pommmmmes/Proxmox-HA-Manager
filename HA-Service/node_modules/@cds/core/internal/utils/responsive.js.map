{"version":3,"file":"responsive.js","sources":["../../../../src/internal/utils/responsive.ts"],"sourcesContent":["/*\n * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\nexport function elementResize(element, callbackFn, async = true) {\n    const observer = new ResizeObserver(() => {\n        // We wrap the callback in requestAnimationFrame to\n        // avoid the error of \"ResizeObserver loop limit exceeded\".\n        if (async) {\n            window.requestAnimationFrame(() => callbackFn());\n        }\n        else {\n            callbackFn();\n        }\n    });\n    observer.observe(element);\n    observer.__testTrigger = callbackFn; // hook to trigger resize event as ResizeObserver does not run in headless chrome.\n    return observer;\n}\nexport function elementVisible(element, callbackFn) {\n    const observer = new IntersectionObserver(entries => {\n        if (entries[0].isIntersecting === true) {\n            callbackFn();\n        }\n    }, { threshold: [0] });\n    observer.observe(element);\n    return observer;\n}\n/**\n * Given a ResponsiveComponent this function will loop through a list of layout\n * options and change the layout of the component until the components layout\n * condition is satisfied.\n */\nexport function calculateOptimalLayout(component, layoutConfig) {\n    return component.updateComplete.then(() => {\n        const currentLayout = component.layout;\n        component.layout = layoutConfig.layouts[0];\n        return layoutConfig.layouts\n            .reduce((prev, next) => {\n            return prev.then(() => {\n                if (component.layout === layoutConfig.initialLayout) {\n                    return next;\n                }\n                else {\n                    const prev = component.layout;\n                    component.layout = next;\n                    return component.updateComplete.then(() => {\n                        component.layout = component.layoutStable ? component.layout : prev;\n                        return next;\n                    });\n                }\n            });\n        }, Promise.resolve(layoutConfig.layouts[0]))\n            .then(() => currentLayout !== component.layout);\n    });\n}\n"],"names":["elementResize","element","callbackFn","async","observer","ResizeObserver","window","requestAnimationFrame","observe","__testTrigger","elementVisible","IntersectionObserver","entries","isIntersecting","threshold","calculateOptimalLayout","component","layoutConfig","updateComplete","then","currentLayout","layout","layouts","reduce","prev","next","initialLayout","layoutStable","Promise","resolve"],"mappings":"AAKO,SAASA,EAAcC,EAASC,EAAYC,GAAQ,GACvD,MAAMC,EAAW,IAAIC,gBAAe,KAG5BF,EACAG,OAAOC,uBAAsB,IAAML,MAGnCA,OAKR,OAFAE,EAASI,QAAQP,GACjBG,EAASK,cAAgBP,EAClBE,EAEJ,SAASM,EAAeT,EAASC,GACpC,MAAME,EAAW,IAAIO,sBAAqBC,KACJ,IAA9BA,EAAQ,GAAGC,gBACXX,MAEL,CAAEY,UAAW,CAAC,KAEjB,OADAV,EAASI,QAAQP,GACVG,EAOJ,SAASW,EAAuBC,EAAWC,GAC9C,OAAOD,EAAUE,eAAeC,MAAK,KACjC,MAAMC,EAAgBJ,EAAUK,OAEhC,OADAL,EAAUK,OAASJ,EAAaK,QAAQ,GACjCL,EAAaK,QACfC,QAAO,CAACC,EAAMC,IACRD,EAAKL,MAAK,KACb,GAAIH,EAAUK,SAAWJ,EAAaS,cAClC,OAAOD,EAEN,CACD,MAAMD,EAAOR,EAAUK,OAEvB,OADAL,EAAUK,OAASI,EACZT,EAAUE,eAAeC,MAAK,KACjCH,EAAUK,OAASL,EAAUW,aAAeX,EAAUK,OAASG,EACxDC,UAIpBG,QAAQC,QAAQZ,EAAaK,QAAQ,KACnCH,MAAK,IAAMC,IAAkBJ,EAAUK"}